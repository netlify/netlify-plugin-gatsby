import path from 'path'
import process from 'process'
import 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'

import { NetlifyPluginOptions } from '@netlify/build'
import { stripIndent } from 'common-tags'
import { existsSync } from 'fs-extra'
import fetch from 'node-fetch'

import { normalizedCacheDir, restoreCache, saveCache } from './helpers/cache'
import {
  createMetadataFileAndCopyDatastore,
  checkConfig,
  getNeededFunctions,
  modifyConfig,
  shouldSkipBundlingDatastore,
  shouldSkip,
} from './helpers/config'
import { modifyFiles } from './helpers/files'
import { deleteFunctions, writeFunctions } from './helpers/functions'
import { prepareImageCdn, PrepareImageCdnResult } from './helpers/image_cdn'
import { checkZipSize } from './helpers/verification'

const DEFAULT_FUNCTIONS_SRC = 'netlify/functions'

let prepareImageCdnResult: PrepareImageCdnResult | undefined

export async function onPreBuild({
  constants,
  netlifyConfig,
  utils,
}: Pick<
  NetlifyPluginOptions,
  'constants' | 'netlifyConfig' | 'utils'
>): Promise<void> {
  const { PUBLISH_DIR } = constants
  // Print a helpful message if the publish dir is misconfigured
  if (!PUBLISH_DIR || process.cwd() === path.resolve(PUBLISH_DIR)) {
    utils.build.failBuild(
      `Gatsby sites must publish the "public" directory, but your site’s publish directory is set to “${PUBLISH_DIR}”. Please set your publish directory to your Gatsby site’s "public" directory.`,
    )
  }

  if (shouldSkip(PUBLISH_DIR)) {
    return
  }

  await restoreCache({ utils, publish: PUBLISH_DIR })

  await checkConfig({ utils, netlifyConfig })

  prepareImageCdnResult = await prepareImageCdn({
    netlifyConfig,
    publish: PUBLISH_DIR,
  })
}

export async function onDev({
  constants,
  netlifyConfig,
}: Pick<NetlifyPluginOptions, 'constants' | 'netlifyConfig'>): Promise<void> {
  // eslint-disable-next-line no-param-reassign
  netlifyConfig.build.environment.GATSBY_PRECOMPILE_DEVELOP_FUNCTIONS = `true`

  const { PUBLISH_DIR } = constants

  const cacheDir = normalizedCacheDir(PUBLISH_DIR)

  const neededFunctionsForBuild = await getNeededFunctions(cacheDir)
  // DSG/SSR engine is not produced for dev so we are filtering them out
  const neededFunctions = neededFunctionsForBuild.filter(
    (neededFunction) => neededFunction !== 'DSG' && neededFunction !== 'SSR',
  )

  await writeFunctions({ constants, netlifyConfig, neededFunctions })

  await modifyConfig({ netlifyConfig, cacheDir, neededFunctions, isDev: true })
}

// eslint-disable-next-line max-statements
export async function onBuild({
  constants,
  netlifyConfig,
}: Pick<NetlifyPluginOptions, 'constants' | 'netlifyConfig'>): Promise<void> {
  const {
    PUBLISH_DIR,
    FUNCTIONS_SRC = DEFAULT_FUNCTIONS_SRC,
    INTERNAL_FUNCTIONS_SRC,
  } = constants

  if (shouldSkip(PUBLISH_DIR)) {
    return
  }

  const cacheDir = normalizedCacheDir(PUBLISH_DIR)

  if (
    INTERNAL_FUNCTIONS_SRC &&
    existsSync(path.join(FUNCTIONS_SRC, 'gatsby'))
  ) {
    console.log(stripIndent`
    Detected the function "${path.join(
      FUNCTIONS_SRC,
      'gatsby',
    )}" that seem to have been generated by an old version of the Essential Gatsby plugin. 
The plugin no longer uses this and it should be deleted to avoid conflicts.\n`)
  }

  if (prepareImageCdnResult?.postBuildCallback) {
    await prepareImageCdnResult.postBuildCallback()
  }

  const neededFunctions = await getNeededFunctions(cacheDir)

  await deleteFunctions(constants)

  if (shouldSkipBundlingDatastore()) {
    console.log('Creating site data metadata file')
    await createMetadataFileAndCopyDatastore(PUBLISH_DIR, cacheDir)
  }

  await writeFunctions({
    constants,
    netlifyConfig,
    neededFunctions,
    prepareImageCdnResult,
  })

  await modifyConfig({ netlifyConfig, cacheDir, neededFunctions, isDev: false })

  await modifyFiles({ netlifyConfig, neededFunctions })
}

export async function onPostBuild({
  constants: { PUBLISH_DIR, FUNCTIONS_DIST },
}: Pick<NetlifyPluginOptions, 'constants'>): Promise<void> {
  if (shouldSkip(PUBLISH_DIR)) {
    return
  }

  const cacheDir = normalizedCacheDir(PUBLISH_DIR)

  const neededFunctions = await getNeededFunctions(cacheDir)

  for (const func of neededFunctions) {
    await checkZipSize(path.join(FUNCTIONS_DIST, `__${func.toLowerCase()}.zip`))
  }
}

export async function onSuccess({
  constants: { PUBLISH_DIR },
  utils,
}: Pick<NetlifyPluginOptions, 'constants' | 'utils'>): Promise<void> {
  if (shouldSkip(PUBLISH_DIR)) {
    return
  }

  await saveCache({ publish: PUBLISH_DIR, utils })

  // Pre-warm the lambdas as downloading the datastore file can take a while
  if (shouldSkipBundlingDatastore()) {
    const FETCH_TIMEOUT = 5000
    const controller = new AbortController()
    const timeout = setTimeout(() => {
      controller.abort()
    }, FETCH_TIMEOUT)

    for (const func of ['api', 'dsg', 'ssr']) {
      const url = `${process.env.DEPLOY_PRIME_URL}/.netlify/functions/__${func}`
      console.log(`Sending pre-warm request to: ${url}`)

      try {
        await fetch(url, { signal: controller.signal })
      } catch (error) {
        console.log('Pre-warm request was aborted', error)
      } finally {
        clearTimeout(timeout)
      }
    }
  }
}
